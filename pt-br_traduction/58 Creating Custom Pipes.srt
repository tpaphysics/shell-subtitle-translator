1
00:00:00,800 --> 00:00:04,940
Os tubos têm 2 casos de uso típicos.

2
00:00:04,940 --> 00:00:08,630
1) "Transformação" onde transformamos *entrada*
dados para a *saída* desejada,

3
00:00:09,470 --> 00:00:14,720
2) E "validação", onde *avaliamos* os dados de entrada
e se -válido-, simplesmente passe por

4
00:00:14,720 --> 00:00:20,210
inalterado. Se os dados forem -inválidos-,
queremos lançar uma exceção.

5
00:00:20,210 --> 00:00:27,210
Em ambos os casos. Pipes operam nos argumentos
sendo processado pelo manipulador de rota de um Controller.

6
00:00:27,210 --> 00:00:31,620
NestJS aciona um Pipe apenas
*antes* de um método ser invocado.

7
00:00:31,620 --> 00:00:35,790
Pipes também recebem os argumentos significados
a ser passado para o método.

8
00:00:35,790 --> 00:00:40,980
Qualquer operação de transformação ou validação
ocorre neste momento.

9
00:00:40,980 --> 00:00:46,360
Depois, o manipulador de rotas é invocado
com quaisquer argumentos potencialmente transformados.

10
00:00:46,360 --> 00:00:49,610
NestJS vem com vários tubos
disponível fora da caixa.

11
00:00:49,610 --> 00:00:51,980
Tudo do pacote @nestjs/common.

12
00:00:51,980 --> 00:00:57,680
Por exemplo ValidationPipe, que vimos em
lições anteriores e ParseArrayPipe, que

13
00:00:57,680 --> 00:01:03,740
não vi, mas é um Pipe extremamente útil
que nos ajuda a analisar e validar Arrays.

14
00:01:03,740 --> 00:01:06,860
Para saber como podemos construir nossos próprios Pipes *personalizados*.

15
00:01:06,860 --> 00:01:13,550
Vamos criar um Pipe que analisa automaticamente qualquer
String para um Integer, e vamos chamá-lo de `

16
00:01:13,940 --> 00:01:15,440
ParseIntPipe`.

17
00:01:15,440 --> 00:01:20,930
Nest já tem um ParseIntPipe que nós
poderia usar da biblioteca @nestjs/common.

18
00:01:20,930 --> 00:01:26,600
Mas vamos criar esse Pipe básico para aprender
propósitos, para nos ajudar a entender completamente o básico

19
00:01:26,600 --> 00:01:28,850
mecânica de um tubo.

20
00:01:28,850 --> 00:01:34,530
Vamos acionar o terminal e gerar um Pipe
classe usando o esquema de tubulação Nest CLI, colocando-o

21
00:01:34,540 --> 00:01:40,350
na pasta common/pipe,
e chamando-o de "parse-int".

22
00:01:40,350 --> 00:01:44,370
Observe que geramos esse pipe no diretório /common/
diretório novamente onde podemos manter as coisas que

23
00:01:44,430 --> 00:01:47,310
não estão vinculados a nenhum domínio específico.

24
00:01:47,310 --> 00:01:50,880
Vamos abrir este ParseIntPipe recém-gerado
arquivo e veja o que temos dentro.

25
00:01:51,780 --> 00:01:58,230
Como podemos ver a Nest CLI gerou um
tubo de exemplo para nós sem qualquer lógica dentro.

26
00:01:58,230 --> 00:02:03,060
Semelhante aos provedores, um Pipe é
uma classe com o decorador @Injectable().

27
00:02:03,060 --> 00:02:09,360
Mas todos os pipes devem implementar o
Interface `PipeTransform` exportada de @nestjs/common.

28
00:02:09,360 --> 00:02:14,430
Esta interface exige que forneçamos
o método transform() dentro de nossa classe.

29
00:02:14,430 --> 00:02:17,850
Este método transform() tem 2 parâmetros.

30
00:02:17,850 --> 00:02:23,430
`value`: o valor de entrada do atualmente processado
argumento antes de ser recebido pela nossa rota

31
00:02:23,430 --> 00:02:25,230
método de manuseio.

32
00:02:25,230 --> 00:02:30,390
E `metadados`. Os metadados de
o argumento atualmente processado.

33
00:02:30,390 --> 00:02:35,940
Qualquer valor retornado por essa transformação
função substitui completamente o valor anterior de

34
00:02:35,940 --> 00:02:38,040
o argumento.

35
00:02:38,040 --> 00:02:40,110
Então, quando isso é útil.

36
00:02:40,110 --> 00:02:45,120
Considere que às vezes os dados passados u200bu200bdo
cliente precisa passar por alguma mudança, antes disso

37
00:02:45,120 --> 00:02:48,900
os dados podem ser tratados adequadamente
pelo método do manipulador de rotas.

38
00:02:48,900 --> 00:02:53,580
Outro caso de uso de exemplo para tubos
seria fornecer valores padrão.

39
00:02:53,580 --> 00:02:56,580
Imagine se tivéssemos alguns requisitos
campos de dados que estavam faltando.

40
00:02:56,580 --> 00:03:00,750
Poderíamos definir automaticamente esses
padrões dentro de um pipe.

41
00:03:00,750 --> 00:03:06,330
Os tubos do transformador podem realizar essas funções
interpondo a função de transformação que criamos -

42
00:03:06,750 --> 00:03:10,590
entre o pedido do cliente -
e o manipulador de solicitações.

43
00:03:11,310 --> 00:03:13,440
Este é apenas mais um exemplo.

44
00:03:13,440 --> 00:03:18,200
Mas o importante é mostrar que existem
muitas coisas poderosas que você pode fazer com tubos.

45
00:03:18,200 --> 00:03:22,350
Tudo bem. Então, de volta para
criando um ParseIntPipe personalizado.

46
00:03:22,350 --> 00:03:25,310
Vamos começar implementando a lógica real.

47
00:03:25,310 --> 00:03:32,040
Primeiro. Podemos supor que o valor de entrada ou `valor`
é uma String para que possamos alterar o tipo de

48
00:03:32,100 --> 00:03:35,450
`qualquer` para `string`.

49
00:03:35,450 --> 00:03:41,360
Próximo. Vamos usar a função JavaScript integrada `parseInt()`
para tentar analisar a string de entrada para um

50
00:03:41,360 --> 00:03:48,270
inteiro.

51
00:03:48,270 --> 00:03:51,360
Vamos adicionar alguma lógica condicional aqui
caso vejamos algum erro.

52
00:03:51,870 --> 00:03:58,570
Se o valor de retorno não for um número,
pode ter certeza de lançar um BadRequestException, caso contrário, nós

53
00:03:58,570 --> 00:04:02,110
pode retornar o valor modificado,
que agora é um número inteiro!

54
00:04:02,110 --> 00:04:03,550
Perfeito.

55
00:04:03,550 --> 00:04:08,400
Com isso no lugar, podemos agora
vincule nosso pipe a alguns decoradores @Param().

56
00:04:08,400 --> 00:04:16,090
Vamos abrir o arquivo CoffeesController
e navegue até o método findOne().

57
00:04:16,090 --> 00:04:17,620
Antes de fazermos qualquer coisa aqui.

58
00:04:17,620 --> 00:04:24,090
Vamos adicionar um único console.log() a
registre os argumentos `id` "valor".

59
00:04:24,090 --> 00:04:31,490
Agora vamos navegar para insônia e executar
uma solicitação GET para o ponto de extremidade /coffees/abc.

60
00:04:31,490 --> 00:04:38,560
Observe que vamos passar "ABC", uma String,
em vez de um número como 1 ou 10.

61
00:04:38,560 --> 00:04:43,090
Vamos mudar para o VSCode e iniciar
o terminal e veja o que foi registrado.

62
00:04:43,090 --> 00:04:47,940
Como podemos ver, ele gera `NaN` ou "não é um número".

63
00:04:47,940 --> 00:04:53,730
Isso significa que embora nosso "id" `abc` não pudesse ter
foi analisado para um número, o método find one

64
00:04:53,730 --> 00:04:56,910
foi chamado com um argumento incorreto.

65
00:04:56,910 --> 00:04:59,340
Para prevenir situações como esta.

66
00:04:59,340 --> 00:05:03,270
Vamos usar nosso ParseIntPipe recém-criado
para validar o parâmetro de entrada.

67
00:05:03,720 --> 00:05:09,210
E caso não seja analisável para um
integer nosso Pipe lançará automaticamente uma validação

68
00:05:09,210 --> 00:05:10,430
exceção para nós.

69
00:05:11,630 --> 00:05:16,430
Então vamos passar nosso ParseIntPipe como o
segundo parâmetro para nosso @Param('id') aqui, salve nosso

70
00:05:16,430 --> 00:05:18,350
alterações e teste o endpoint novamente

71
00:05:26,660 --> 00:05:32,720
. Ótimo como podemos ver desta vez que recebemos
um erro 400 com a mensagem informando que "validation

72
00:05:32,780 --> 00:05:34,590
fracassado".

73
00:05:34,590 --> 00:05:39,840
Como dissemos, o Nest já vem com esse Pipe,
mas espero que este exemplo mostre o poder de

74
00:05:39,840 --> 00:05:45,150
Pipes e como você pode implementar o seu próprio para
fazer uma infinidade de processos úteis para o seu

75
00:05:45,150 --> 00:05:45,720
inscrição.

