1
00:00:01,030 --> 00:00:03,610
Os guardas têm uma única responsabilidade.

2
00:00:03,610 --> 00:00:08,960
Que é determinar se um dado
request é permitido o acesso a algo.

3
00:00:08,960 --> 00:00:16,100
Se a solicitação atender a determinadas condições,
como permissões, papéis, ACLs, etc.

4
00:00:16,100 --> 00:00:18,770
Ele *será* permitido o acesso a essa rota.

5
00:00:18,770 --> 00:00:24,890
Se as condições *NÃO* forem atendidas, isso será
ser *negado* e um erro será lançado.

6
00:00:24,890 --> 00:00:29,720
Um dos melhores casos de uso para
Guardas: é Autenticação e Autorização.

7
00:00:29,720 --> 00:00:35,600
Por exemplo, poderíamos implementar um Guard que extraia
e valida um Token e usa o extrato

8
00:00:35,600 --> 00:00:40,110
informações para determinar se o
pedido pode prosseguir ou não.

9
00:00:40,110 --> 00:00:45,790
Uma vez que existem muitas abordagens diferentes e
estratégias para lidar com autenticação e autorização.

10
00:00:45,790 --> 00:00:51,160
Neste vídeo, vamos nos concentrar em um exemplo simplificado
e aprenda como alavancar os próprios Guardas em nosso

11
00:00:51,160 --> 00:00:57,310
projetos. Se você estiver interessado em aprender mais
sobre Autenticação em si, confira nosso

12
00:00:57,310 --> 00:01:03,220
Extensão de Curso, que é particularmente
sobre a implementação de um Enterprise-grade

13
00:01:03,250 --> 00:01:08,140
Recurso de autenticação e todos os
complexidades que acompanham isso.

14
00:01:08,140 --> 00:01:13,240
Tudo bem. Então, para aprender como os Guardas funcionam conceitualmente,
vamos criar um Guard que seja responsável por 2

15
00:01:13,240 --> 00:01:18,850
coisas:. 1) Validando se uma API_KEY
está presente em um cabeçalho de "autorização".

16
00:01:18,850 --> 00:01:24,220
2) E em segundo lugar se a rota
sendo acessado é especificado como "público".

17
00:01:24,220 --> 00:01:26,590
Vamos chamar esse novo guarda de `ApiKeyGuard`.

18
00:01:27,580 --> 00:01:32,890
Vamos iniciar o terminal e gerar
uma classe de guarda usando a Nest CLI.

19
00:01:32,890 --> 00:01:39,370
Vamos entrar em: `ninho
g guard comum/guards/api-key

20
00:01:39,820 --> 00:01:44,110
Observe que geramos esse guarda no arquivo /common/
diretório, onde podemos manter coisas que não são

21
00:01:44,110 --> 00:01:46,920
vinculado a qualquer domínio específico.

22
00:01:46,920 --> 00:01:52,910
Tudo bem, então vamos abrir este recém-gerado
ApiKeyGuard e veja o que temos dentro.

23
00:01:52,910 --> 00:01:58,160
Como podemos ver a Nest CLI gerou um exemplo
guarda para nós, sem qualquer lógica dentro, é claro.

24
00:01:58,940 --> 00:02:00,090
Semelhante aos provedores.

25
00:02:00,380 --> 00:02:06,340
Um guarda é apenas uma classe com o
@Injectable decorador que vimos em vídeos anteriores.

26
00:02:06,340 --> 00:02:10,930
Um requisito importante dos guardas é que
eles devem implementar a interface `canActivate`

27
00:02:11,110 --> 00:02:14,380
exportado de @nestjs/common.

28
00:02:14,380 --> 00:02:19,090
Esta interface exige que forneçamos
o método canActivate() dentro de nossa classe.

29
00:02:19,090 --> 00:02:24,580
Este método canActivate deve retornar um Boolean,
indicando se a solicitação atual é permitida

30
00:02:24,580 --> 00:02:27,760
para prosseguir OU acesso negado.

31
00:02:27,760 --> 00:02:34,000
Este método também pode retornar uma resposta que é
síncrona ou assíncrona, como uma promessa

32
00:02:34,060 --> 00:02:35,690
ou Observável.

33
00:02:35,690 --> 00:02:39,610
Nest usará o valor de retorno
para controlar a próxima ação.

34
00:02:39,610 --> 00:02:43,120
Se retornar `true`: o
pedido será processado.

35
00:02:43,120 --> 00:02:46,270
Se retornar `false`: Nest negará a solicitação.

36
00:02:47,110 --> 00:02:51,280
Olhando para o código de exemplo o
Nest CLI gerado para nós aqui.

37
00:02:51,280 --> 00:02:54,490
Temos o `return true` codificado por enquanto.

38
00:02:54,490 --> 00:02:58,300
Isso significa que atualmente, cada solicitação
será permitido prosseguir!

39
00:02:58,300 --> 00:03:05,320
Apenas para fins de teste, vamos alterar esta linha
para `return false`, indicando que cada solicitação

40
00:03:05,470 --> 00:03:07,060
deve ser *negado* o acesso.

41
00:03:07,930 --> 00:03:11,400
E agora que nosso Mock Guard inicial está pronto.

42
00:03:11,400 --> 00:03:14,590
Vamos vinculá-lo ao nosso aplicativo "globalmente".

43
00:03:14,590 --> 00:03:17,970
Vamos abrir o arquivo main.ts.

44
00:03:17,970 --> 00:03:25,790
E adicione `appUseGlobalGuards()` passando em nosso
novo ApiKeyGuard dentro dele.

45
00:03:27,430 --> 00:03:32,630
Excelente. Vamos garantir que nosso aplicativo seja
rodando em segundo plano, e vamos navegar para

46
00:03:32,630 --> 00:03:35,910
insônia e testar qualquer ponto final.

47
00:03:35,910 --> 00:03:42,690
Como podemos ver TODOS os nossos endpoints agora
responder com o status "403 Forbidden Resource", assim como nós

48
00:03:42,690 --> 00:03:46,030
esperado. Funcionou perfeitamente.

49
00:03:46,030 --> 00:03:52,270
Mas agora nossa Guarda não está programaticamente
determinar qualquer coisa sobre nossa rota ou o chamador

50
00:03:52,270 --> 00:03:54,910
ainda. Está simplesmente sempre retornando 'false'.

51
00:03:55,410 --> 00:03:58,150
Isso não faz muito sentido certo?

52
00:03:58,150 --> 00:04:01,930
Em vez disso, vamos configurar nossa Guarda para lidar com o
cenário sobre o qual falamos no início deste

53
00:04:01,930 --> 00:04:03,280
lição.

54
00:04:03,280 --> 00:04:09,190
Que é "validar uma API_KEY que deve ser
presente em cada solicitação", mas -somente- em rotas

55
00:04:09,250 --> 00:04:11,770
que *não* são especificados como "públicos".

56
00:04:11,770 --> 00:04:14,300
Então, como podemos começar aqui.

57
00:04:14,300 --> 00:04:18,890
Bem, primeiro vamos definir isso
API_KEY que estamos falando.

58
00:04:18,890 --> 00:04:23,210
Para ter certeza de que *nunca* empurramos
esta "chave secreta" para o nosso repositório git.

59
00:04:23,210 --> 00:04:26,030
Vamos definir a API_KEY
como uma variável de ambiente.

60
00:04:26.600 --> 00:04:33.950
Abra nosso arquivo .env que criamos em
uma lição anterior e vamos adicionar o seguinte `API_KEY`

61
00:04:33,950 --> 00:04:36,050
linha.

62
00:04:36,050 --> 00:04:42,090
A API_KEY aqui é apenas uma String gerada aleatoriamente, então
sinta-se à vontade para usar o que quiser para isso

63
00:04:42,090 --> 00:04:44,010
exemplo.

64
00:04:44,010 --> 00:04:47,930
Com isso no lugar. Vamos voltar para a nossa Guarda.

65
00:04:47,930 --> 00:04:54,300
Aqui em nossa guarda. Queremos recuperar a API_KEY
de qualquer solicitação recebida que não seja rotulada como

66
00:04:54,300 --> 00:04:58,490
público. Nós estaremos lidando com isso
parte pública em um momento.

67
00:04:58,490 --> 00:05:04,620
Para nossa API_KEY. Vamos supor que o chamador
está passando essa chave como um "cabeçalho de autorização".

68
00:05:04,620 --> 00:05:08,640
Para obter as informações sobre
esta solicitação HTTP de entrada.

69
00:05:08,640 --> 00:05:13,740
Precisamos acessar tudo de
o ExecutionContext (parâmetro "context"), que herda de

70
00:05:13,740 --> 00:05:19,560
ArgumentsHost, com o qual já nos familiarizamos
quando o usamos com a exceção

71
00:05:19,560 --> 00:05:21,160
Filtro.

72
00:05:21,160 --> 00:05:26,470
Na verdade, podemos usar esses mesmos métodos auxiliares de
antes, mas desta vez, para obter a referência de

73
00:05:26,470 --> 00:05:30,490
o objeto Request em vez de Response.

74
00:05:30,490 --> 00:05:36,940
Este método switchToHttp(), nos dá acesso a
a solicitação nativa em voo, a resposta e o próximo

75
00:05:36,940 --> 00:05:40,120
objetos! Que é exatamente o que precisamos.

76
00:05:40,120 --> 00:05:45,430
Em seguida, precisamos chamar o método getRequest()
nele, que retornará a nossa plataforma subjacente

77
00:05:45,520 --> 00:05:47,620
Objeto wrapper de solicitação.

78
00:05:47,860 --> 00:05:51,400
Lembre-se que no Nest este é o Express.js Por padrão.

79
00:05:51,400 --> 00:05:54,410
Mas também pode ser trocado por Fastify.

80
00:05:54,410 --> 00:05:56,420
Para melhor segurança de tipo aqui.

81
00:05:56,420 --> 00:06:03,090
Vamos especificar o tipo como uma importação `Request`
este Digite do pacote "express" novamente.

82
00:06:03,090 --> 00:06:08,910
Agora vamos usar este objeto Request para recuperar
o cabeçalho "autorização" de cada solicitação, se for

83
00:06:08,910 --> 00:06:16,810
mesmo lá. Por último, vamos comparar a autorização
cabeçalho passado, com a API_KEY registrada

84
00:06:16.900 --> 00:06:19.600
nós armazenamos em nossa variável de ambiente.

85
00:06:19.600 --> 00:06:25.000
Por enquanto vamos simplesmente acessar o ambiente
variáveis u200bu200busando o objeto `process.env`, mas idealmente

86
00:06:25,060 --> 00:06:28,610
você gostaria de aproveitar
o (@nestjs/config) `ConfigService` em vez disso.

87
00:06:28,610 --> 00:06:29,750
Com tudo isso no lugar.

88
00:06:29,870 --> 00:06:35,180
Vamos abrir a insônia e testar *qualquer* ponto final em
nossa aplicação, e veja se nosso Guard funciona assim

89
00:06:35,180 --> 00:06:43,740
distante. Como podemos ver nossa aplicação
respondeu com o status 403 Forbidden Resource.

90
00:06:43,740 --> 00:06:49,200
Como não passamos nenhuma autorização
header especialmente um com nossa API_KEY específica.

91
00:06:49,200 --> 00:06:52,150
Parece que nossa Guarda está funcionando perfeitamente.

92
00:06:52,150 --> 00:06:57,760
Vamos tentar a mesma solicitação de API novamente, mas isso
tempo vamos adicionar um cabeçalho "autorização" com o

93
00:06:57,760 --> 00:07:04,140
API_KEY correta.

94
00:07:04,140 --> 00:07:05,070
Com isso no lugar.

95
00:07:05,190 --> 00:07:09,410
Vamos clicar em enviar e chamar o endpoint novamente.

96
00:07:09,410 --> 00:07:13,250
Perfeito. Temos uma resposta 200
de volta e nenhum erro desta vez!

97
00:07:13,250 --> 00:07:18,770
A nossa Guarda pôde verificar que a autorização
header correspondeu à nossa API_KEY secreta e fomos

98
00:07:18,770 --> 00:07:21,440
acesso permitido para continuar a solicitação da API.

99
00:07:21,830 --> 00:07:28,160
Até agora, terminamos de configurar a API_KEY
funcionalidade de validação que queríamos, mas ainda não estamos

100
00:07:28,160 --> 00:07:32,150
verificando se a rota específica que está sendo
acessado é "público" ou não.

101
00:07:32,150 --> 00:07:37,700
No próximo capítulo, veremos como Metadados e
alguns outros recursos do Nest podem nos ajudar a alcançar

102
00:07:37,820 --> 00:07:38,510
só isso!

