1
00:00:00,820 --> 00:00:05,950
Middleware é uma função que é chamada *antes* do
manipulador de rota e quaisquer outros blocos de construção são

2
00:00:05,950 --> 00:00:11,660
processado. Isso inclui interceptadores,
Guardas e Tubulações.

3
00:00:11,660 --> 00:00:17,210
As funções de middleware têm acesso ao Request &
Objetos de resposta e *não* especificamente vinculados

4
00:00:17,210 --> 00:00:22,520
para *qualquer método*, mas sim
para um "caminho de rota" especificado.

5
00:00:22,520 --> 00:00:24,710
As funções de middleware podem executar
as seguintes tarefas:.

6
00:00:25,550 --> 00:00:27,710
1) Executando o código.

7
00:00:27,710 --> 00:00:31,520
2) Fazendo alterações no
objetos de solicitação e resposta.

8
00:00:31,520 --> 00:00:33,560
3) Encerrando o ciclo de solicitação/resposta.

9
00:00:34,130 --> 00:00:38,480
4) Ou até mesmo chamando o `next()`
função de middleware na pilha de chamadas.

10
00:00:38,480 --> 00:00:44,210
Ao trabalhar com middleware, se o atual
função de middleware não finaliza a solicitação/resposta

11
00:00:44,270 --> 00:00:45,290
ciclo.

12
00:00:45,290 --> 00:00:51,740
Ele *deve* chamar o método `next()`, que
passa o controle para a próxima função de middleware.

13
00:00:51,740 --> 00:00:56,100
Caso contrário, o pedido será
esquerda -pendurado-, e nunca completo.

14
00:00:56,100 --> 00:00:59,970
Então, como podemos obter
começamos a criar nosso próprio middleware.

15
00:00:59,970 --> 00:01:05,000
O middleware Nest personalizado pode ser implementado em
uma Função ou uma Classe.

16
00:01:05.000 --> 00:01:10.410
O middleware de função é "sem estado", ele *não* pode injetar
dependências, e não tem acesso ao

17
00:01:10,410 --> 00:01:12,060
Recipiente ninho.

18
00:01:12,060 --> 00:01:16,800
Por outro lado. O middleware de classe pode
confiar em dependências externas e injetar provedores

19
00:01:16,890 --> 00:01:19,620
registrado no mesmo escopo do módulo.

20
00:01:19,620 --> 00:01:22,710
Neste vídeo vamos focar
na construção de um middleware de classe.

21
00:01:22,710 --> 00:01:26,640
Mas lembre-se que você sempre pode usar
Funções para criá-los também.

22
00:01:26,640 --> 00:01:30,870
Vamos iniciar o terminal e gerar um middleware
class usando a CLI e vamos chamá-la

23
00:01:30,870 --> 00:01:36,300
"exploração madeireira". Observe que geramos esse middleware em
o diretório /common/ novamente, pois não é

24
00:01:36,300 --> 00:01:39,220
vinculado a qualquer domínio específico.

25
00:01:39,220 --> 00:01:44,440
Vamos abrir este LoggingMiddleware recém-gerado
arquivo e veja o que temos dentro.

26
00:01:44,440 --> 00:01:49,080
Como podemos ver o Nest CLI gerado
um middleware de exemplo sem nenhuma lógica interna.

27
00:01:49,750 --> 00:01:55,420
Semelhante a Provedores em Middleware é
uma classe com o decorador @Injectable().

28
00:01:55,420 --> 00:02:02,080
Todo middleware deve implementar o
Interface `NestMiddleware` exportada de @nestjs/common.

29
00:02:02,080 --> 00:02:07,510
Esta interface exige que forneçamos
o método `use()` dentro de nossa classe.

30
00:02:07,510 --> 00:02:10,390
Este método, não
tem quaisquer requisitos especiais.

31
00:02:10,810 --> 00:02:17,830
Apenas lembre-se de *sempre* chamar a função `next()`
caso contrário, a solicitação ficará suspensa.

32
00:02:17,830 --> 00:02:24,490
Por enquanto vamos manter as coisas simples, vamos apenas
adicione um console.log() antes de invocar a função next()

33
00:02:24,520 --> 00:02:29,710
para ver como o middleware se encaixa
no ciclo de vida de solicitação/resposta.

34
00:02:29,710 --> 00:02:34,240
Com isso colocado podemos
agora registre nosso middleware recém-criado.

35
00:02:34,240 --> 00:02:38,950
Como mencionamos anteriormente, o middleware não é
especificamente vinculado a qualquer método.

36
00:02:38,950 --> 00:02:43,000
Não podemos ligá-los em
uma forma declarativa usando decoradores.

37
00:02:43.000 --> 00:02:47.830
Em vez disso, vinculamos o middleware a um
caminho de rota, representado como uma String.

38
00:02:47,830 --> 00:02:50,590
Para registrar nosso LoggingMiddleware.

39
00:02:50,590 --> 00:02:53,950
Vamos abrir nosso arquivo CommonModule.

40
00:02:53,950 --> 00:03:02,420
Primeiro vamos ter certeza de que nosso
A classe CommonModule implementa a interface NestModule.

41
00:03:02,420 --> 00:03:07,820
Essa interface exige que forneçamos o
`configure()`, que leva o MiddlewareConsumer

42
00:03:07,880 --> 00:03:09,790
como argumento.

43
00:03:09,790 --> 00:03:16,920
O MiddlewareConsumer fornece um conjunto de
métodos para vincular o middleware a rotas específicas.

44
00:03:16,920 --> 00:03:21,260
Só para testar. Vamos aplicar o LoggingMiddleware
para *todas* rotas, usando o Asteriks*, ou

45
00:03:21,270 --> 00:03:23,400
"operador curinga".

46
00:03:23,400 --> 00:03:24,870
Para adicionar nosso middleware.

47
00:03:24,870 --> 00:03:29,550
Vamos chamar o método `apply()` em
`consumer`, passando em nosso `LoggingMiddleware`.

48
00:03:29,550 --> 00:03:35,700
E então vamos chamar o método `.forRoutes(*)`,
passando o curinga Asteriks *.

49
00:03:35,700 --> 00:03:41,460
Vamos salvar nossas alterações e navegar até a insônia
e execute uma solicitação HTTP para *qualquer* endpoint.

50
00:03:43,080 --> 00:03:47,260
Vamos voltar ao VSCode e ver
se alguma coisa apareceu em nosso terminal.

51
00:03:47,260 --> 00:03:51,400
Excelente. Podemos ver "Oi de
middleware" String em nosso console.

52
00:03:51.400 --> 00:03:53.950
Agora dando um passo para trás
ao nosso middleware `consumidor`.

53
00:03:54,580 --> 00:03:58,810
Existem várias outras formas de
amarrando middleware a diferentes caminhos de rota.

54
00:03:58,810 --> 00:04:04,000
Até agora, vinculamos o LoggingMiddleware a *todos*
rota usando o curinga Asterisk *.

55
00:04:04.000 --> 00:04:10.000
Mas também poderíamos aplicar apenas a rotas com,
digamos o prefixo "cafés" se quisermos.

56
00:04:10.000 --> 00:04:15.730
Podemos até restringir ainda mais o middleware se quisermos
digamos a um método de solicitação específico como

57
00:04:15,820 --> 00:04:25,570
apenas para métodos `GET`, passando um objeto contendo
o caminho da rota e o método de solicitação assim.

58
00:04:25,570 --> 00:04:30,580
Observe que importamos o método Request Enum que
usado em lições anteriores para referenciar o

59
00:04:30,580 --> 00:04:33,670
tipo de método de solicitação.

60
00:04:33,670 --> 00:04:38,620
Por último, também podemos -excluir- certas rotas de
tendo o middleware aplicado com o `exclude()`

61
00:04:38,620 --> 00:04:45,460
método. Este método pode levar um único
String, vários Strings ou um objeto RouteInfo.

62
00:04:45,550 --> 00:04:48,040
Identificando rotas a serem excluídas.

63
00:04:48,040 --> 00:04:52,630
Por exemplo, podemos aplicar o middleware a cada
rota -exceto- para aqueles com o prefixo "cafés"

64
00:04:52,630 --> 00:04:56,790
se quiséssemos.

65
00:04:56,790 --> 00:04:59,730
Agora que vimos alguns
das opções disponíveis para nós aqui.

66
00:05:00,390 --> 00:05:05,160
Vamos voltar ao nosso original `forRoutes(*)`
curinga, pois queremos vincular o

67
00:05:05,160 --> 00:05:08,270
LoggingMiddleware para *todo* existente
ponto final por enquanto.

68
00:05:08,270 --> 00:05:13,760
Vamos abrir o arquivo LoggingMiddleware novamente
e adicione algumas funcionalidades adicionais aqui.

69
00:05:13,760 --> 00:05:19,130
Para um exemplo divertido, vamos calcular "quanto tempo"
todo o ciclo de solicitação/resposta leva, usando

70
00:05:19,130 u200bu200b--> 00:05:20,210
console.time().

71
00:05:21,050 --> 00:05:27,050
Observe que este cálculo incluirá a
Interceptores, Filtros, Guardas, manipuladores de métodos etc.

72
00:05:27,080 --> 00:05:29,480
que esta rota também pode ter!

73
00:05:29,480 --> 00:05:34,610
Neste exemplo, estamos nos conectando ao Express.js
Resposta "terminar" evento para que saibamos quando nosso

74
00:05:34,610 --> 00:05:37,280
console.timeEnd() deve ocorrer.

75
00:05:37,280 --> 00:05:40,700
Vamos salvar nossas alterações e navegar até a insônia.

76
00:05:40,700 --> 00:05:48,250
Agora vamos executar uma requisição HTTP aleatória para
nosso aplicativo e volte para o terminal.

77
00:05:48,250 --> 00:05:53,360
Como podemos ver, há uma nova solicitação/resposta
mensagem indicando que a viagem completa de ida e volta levou um

78
00:05:53,370 --> 00:05:56,170
aproximadamente 23 milissegundos.

79
00:05:56,170 --> 00:06:01,180
Isso tudo foi um exemplo básico, mas espero que isso
mostra o potencial que o middleware traz para

80
00:06:01,180 --> 00:06:02,860
uma aplicação.

81
00:06:02,860 --> 00:06:08,590
Para um caso de uso mais realista, você poderia
utilizar algo como o que acabamos de criar, para

82
00:06:08,590 --> 00:06:14,080
registrar "métodos de longa duração" em um banco de dados e manter
acompanhar quanto tempo cada API leva para ser concluída.

