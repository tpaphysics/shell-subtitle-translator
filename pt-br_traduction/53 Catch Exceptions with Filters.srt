1
00:00:01,230 --> 00:00:07,080
NestJS vem com uma "camada" de Exceções embutida,
responsável pelo processamento de todas as Exceções não tratadas

2
00:00:07,080 --> 00:00:09,090
em todo o nosso aplicativo.

3
00:00:09,090 --> 00:00:14,490
Quando uma exceção *não* é tratada pelo nosso
aplicativo, ele é automaticamente capturado por esta camada,

4
00:00:14,790 --> 00:00:18,720
que envia o
resposta amigável apropriada.

5
00:00:18,720 --> 00:00:22,500
Sai da caixa. Esta ação é
executado por um ExceptionFilter global integrado.

6
00:00:23,280 --> 00:00:28,680
Embora este ExceptionFilter integrado básico possa
lidar com muitos casos de uso para nós.

7
00:00:29,040 --> 00:00:30,780
Nós *podemos* querer controle total sobre isso.

8
00:00:31,620 --> 00:00:37,320
Por exemplo, podemos querer adicionar log de exceção
ou retornar nossos erros em um JSON diferente

9
00:00:37,320 --> 00:00:39,400
esquema.

10
00:00:39,400 --> 00:00:42,970
Filtros de exceção são projetados
exatamente para isso!

11
00:00:42,970 --> 00:00:48,520
Eles nos deixam encarregados do "fluxo" exato
de controle" e o "conteúdo" da Resposta que está sendo enviada

12
00:00:48,520 --> 00:00:51,240
de volta ao cliente.

13
00:00:51,240 --> 00:00:56,550
Vamos criar um ExceptionFilter, que é responsável por
captura de exceções que são uma instância de

14
00:00:56,550 --> 00:01:02,960
a classe HttpException e implementamos nosso
própria lógica de resposta personalizada para ele.

15
00:01:02,960 --> 00:01:08,060
Vamos começar acionando nosso terminal e
gerando uma classe de filtro usando o filtro Nest CLI

16
00:01:08,060 --> 00:01:09,560
esquema, digitando:.

17
00:01:10,220 --> 00:01:16,280
Nest g filter common/filters/http-exception

18
00:01:17.000 --> 00:01:21.500
Observe que geramos esse filtro em um /common/
diretório, onde podemos manter coisas que *não* são

19
00:01:21.500 --> 00:01:23.990
vinculado a qualquer domínio específico.

20
00:01:23,990 --> 00:01:29,930
Vamos abrir o HttpExceptionFilter recém-gerado,
e veja o que temos dentro.

21
00:01:29,930 --> 00:01:36,020
Como você pode ver, a Nest CLI gerou um
filtro de exemplo, sem qualquer lógica de negócios, é claro.

22
00:01:36,020 --> 00:01:41,800
O decorador @Catch() no topo, liga
os metadados necessários para o ExceptionFilter.

23
00:01:41,800 --> 00:01:46,550
Este decorador @Catch() pode levar um único
parâmetro ou uma lista separada por vírgulas.

24
00:01:47,270 --> 00:01:52,490
Isso nos permite configurar um filtro para vários
tipos de exceções de uma só vez, se quisermos.

25
00:01:52,490 --> 00:01:56,690
Como queremos processar todos
exceções que são instâncias de HttpException.

26
00:01:57,320 --> 00:02:05,700
Vamos passar o HttpException
classe entre parênteses.

27
00:02:05,700 --> 00:02:12,600
Todos os ExceptionFilters devem implementar o
Interface `ExceptionFilter` exportada de @nestjs/common.

28
00:02:12,600 --> 00:02:18,780
Esta interface requer que forneçamos o
catch() com sua assinatura de método indicada.

29
00:02:18,780 --> 00:02:24,030
Também podemos ver que nossa classe aceita um Type
<> Argumento, que indica o Tipo da exceção

30
00:02:24,060 --> 00:02:26,880
argumento em nosso método catch().

31
00:02:26,880 --> 00:02:31,380
Novamente, uma vez que queremos processar todos
exceções que são instâncias de um HttpException.

32
00:02:31,950 --> 00:02:35,500
Vamos mudar isso para

33
00:02:37,530 --> 00:02:43,530
Tudo bem com toda essa configuração agora
podemos implementar nossa lógica de resposta personalizada.

34
00:02:43,530 --> 00:02:48,540
Para isso, precisamos acessar o
plataformas subjacentes Response\{} objeto para que possamos

35
00:02:48,540 --> 00:02:54,510
*manipule ou transforme* e
CONTINUE enviando a resposta -depois-.

36
00:02:54,510 --> 00:02:58,140
Então, onde podemos obter um
manter a resposta original?

37
00:02:58,140 --> 00:03:04,320
Vamos usar o segundo parâmetro aqui, "host", que
pode ver como uma instância de `ArgumentsHost`, e

38
00:03:04,320 --> 00:03:06,940
chame o método switchToHttp() nele.

39
00:03:07,980 --> 00:03:13,260
Salvando isso como a variável
`ctx`, abreviação de "contexto".

40
00:03:13,260 --> 00:03:20,330
Este método switchToHttp() nos dá acesso a
os objetos de solicitação ou resposta em trânsito nativos.

41
00:03:20,330 --> 00:03:23,270
Que é exatamente o que precisamos aqui.

42
00:03:23,270 --> 00:03:27,890
Em seguida, vamos usar esta variável `ctx`, e
chame o método `getResponse()` nele.

43
00:03:28,890 --> 00:03:32,490
Este método retornará
nossas -plataformas subjacentes- Response.

44
00:03:32,940 --> 00:03:39,170
Lembre-se no NestJS, este é o Express.js por padrão,
mas também pode ser trocado por Fastify.

45
00:03:39,170 --> 00:03:41,420
Para melhor segurança de tipo aqui.

46
00:03:41,420 --> 00:03:44,870
Vamos especificar o Tipo como uma "Resposta".

47
00:03:44,870 --> 00:03:49,930
importando este tipo do pacote "express".

48
00:03:49,930 --> 00:03:51,220
Agora que temos nossa resposta.

49
00:03:52.000 --> 00:03:58.420
Vamos usar o parâmetro "exceção" disponível para nós
no método *this* e extraia 2 coisas.

50
00:03:58,420 --> 00:04:02,790
O "statusCode" e o "corpo"
da exceção atual.

51
00:04:02,790 --> 00:04:09,840
Para obter o status, podemos simplesmente chamar
o método `getStatus()` como vemos aqui.

52
00:04:09,840 --> 00:04:15,660
Vamos também obter a exceção bruta
Resposta, chamando o método `getResponse()` e salvando

53
00:04:15,660 --> 00:04:18,210
isso para uma variável também.

54
00:04:18,210 --> 00:04:23,240
Como para fins de demonstração - estamos tentando
passar de volta esta resposta de erro "original", precisamos

55
00:04:23,240 --> 00:04:26,170
para fazer um pouco de trabalho aqui.

56
00:04:26,170 --> 00:04:30,430
Primeiro precisamos testar se o
A resposta é uma String ou um Object.

57
00:04:30,430 --> 00:04:37,190
Se for uma string vamos criar um Object
e coloque essa String dentro da propriedade message.

58
00:04:37,190 --> 00:04:42,350
Caso contrário, estamos todos prontos em nosso
exceptionResponse já é um objeto.

59
00:04:42,350 --> 00:04:47,390
Fazendo tudo isso. Nossos erros serão agora
bastante "uniforme", e podemos (...) espalhar esse erro

60
00:04:47,390 --> 00:04:51,820
variável em nossa resposta final, que
faremos em instantes!

61
00:04:51,820 --> 00:04:54,320
Ótimo, agora que temos tudo o que precisamos.

62
00:04:54,320 --> 00:04:59,150
Vamos começar a construir nossa resposta
*de volta* que enviaremos.

63
00:04:59,150 --> 00:05:03,810
Primeiro vamos definir o statusCode para a resposta que estamos
vai enviar de volta através do método `status()`.

64
00:05:03,810 --> 00:05:11,880
(`response.status(status)`) Por último, precisamos
envie o `exceptionResponse` de volta.

65
00:05:11,880 --> 00:05:16,410
Nossa plataforma subjacente de aplicativos é
Express.js, que é o padrão.

66
00:05:16,410 --> 00:05:19,020
Portanto, existem várias maneiras de fazer isso!

67
00:05:19,020 --> 00:05:22,380
No nosso caso. Vamos só
use o método `.json()` do express.

68
00:05:23,160 --> 00:05:28,590
Podemos simplesmente encadear este método após nosso status()
call (como vemos aqui), e usando o (...)spread

69
00:05:28,590 --> 00:05:35,220
operador, podemos passar o erro original de
nossa Exception dentro deste método .json().

70
00:05:35,220 --> 00:05:39,960
A partir de agora. Nosso ExceptionFilter aqui
ainda não está fazendo nada único.

71
00:05:39,960 --> 00:05:44,070
Então vamos passar algo personalizado
aqui junto com a exceção original.

72
00:05:44,070 --> 00:05:49,100
Desta forma, temos algo que podemos procurar em
todos os nossos erros para garantir que tudo com o

73
00:05:49,110 --> 00:05:51,620
ExceptionFilter funciona!

74
00:05:51,620 --> 00:05:54,800
Vamos adicionar uma nova propriedade `timestamp` e
dê a ele o valor de new Date().

75
00:05:54,800 --> 00:05:56,840
toISOString(). Excelente.

76
00:05:57,140 --> 00:06:02,570
Agora com tudo isso no lugar, vamos
vincule este ExceptionFilter global ao nosso aplicativo.

77
00:06:02,570 --> 00:06:08,270
Como não precisamos de fornecedores externos, aqui
podemos apenas vincular este ExceptionFilter globalmente

78
00:06:08,270 --> 00:06:12,530
usando a instância `app` em nosso arquivo main.ts.

79
00:06:12,530 --> 00:06:16,380
Vamos para o arquivo main.ts
e adicione-o bem rápido com `app.

80
00:06:16,460 --> 00:06:17,660
useGlobalFilters()`.

81
00:06:19,670 --> 00:06:24,450
Passando: `new HttpExceptionFilter()` dentro.

82
00:06:24,450 --> 00:06:26,010
Agora que está tudo no lugar.

83
00:06:26,010 --> 00:06:29,040
Vamos testá-lo acionando alguns erros de API!

84
00:06:29,040 --> 00:06:34,710
Vamos ter certeza de que nosso aplicativo está sendo executado em nosso
terminal e, se não, certifique-se de executar: `npm run

85
00:06:34,830 --> 00:06:36,860
start:dev` novamente.

86
00:06:36,860 --> 00:06:38,220
Com nosso aplicativo em execução.

87
00:06:38,310 --> 00:06:43,950
Vamos abrir a insônia e realizar uma solicitação GET
para um recurso *não existente* e faça propositalmente

88
00:06:43,950 --> 00:06:46,030
um erro acontecer!

89
00:06:46,030 --> 00:06:54,010
Vamos encontrar algo como /coffees/-1 onde "-1", é obviamente
um "id" que não temos no banco de dados.

90
00:06:54,010 --> 00:07:00,220
Como podemos ver a resposta voltou com
um erro e claramente usou nosso novo ExceptionFilter personalizado!

91
00:07:00,220 --> 00:07:03,230
Como a resposta contém
nossa nova propriedade `timestamp`.

92
00:07:03,230 --> 00:07:09,100
Perfeito. Então, naturalmente, esta exceção nós
criado foi uma implementação de exemplo básico.

93
00:07:09,100 --> 00:07:13,630
Mas você pode ver que dentro deste ExceptionFilter, nós
poderia ter facilmente usado algum tipo de

94
00:07:13,630 --> 00:07:17,830
Logging Service para rastrear nossos erros,
talvez até chamado de API do Analytics.

95
00:07:18,550 --> 00:07:23,320
Qualquer coisa que gostaríamos de fazer sempre
um HttpException ocorre em nosso aplicativo.

