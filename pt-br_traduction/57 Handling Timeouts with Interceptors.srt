1
00:00:00,790 --> 00:00:06,010
Até agora aprendemos como usar o Interceptor
para vincular a lógica extra *antes* e *depois* do método

2
00:00:06,010 --> 00:00:11,560
execução, bem como registrar automaticamente e
*transformando* resultados retornados de manipuladores de rotas

3
00:00:12.500 --> 00:00:19.410
. Outra técnica útil para interceptores é
estender o comportamento básico da função aplicando

4
00:00:19,830 --> 00:00:23,240
Operadores RxJS para o fluxo de resposta.

5
00:00:23,240 --> 00:00:26,700
Vamos ver isso em ação com um exemplo realista.

6
00:00:26,700 --> 00:00:29,820
Para nos ajudar a aprender sobre este conceito por exemplo.

7
00:00:29,820 --> 00:00:34,530
Vamos imaginar que precisamos lidar
"timeouts" para todas as nossas solicitações de rota.

8
00:00:34,530 --> 00:00:39,780
Quando um endpoint *não* retorna nada após um
certo período de tempo, precisamos -terminar-

9
00:00:39,780 --> 00:00:43,350
a solicitação e envie de volta uma mensagem de erro.

10
00:00:43,350 --> 00:00:47,940
Vamos começar gerando outro interceptor, nomeando-o
"timeout", e também colocando-o no

11
00:00:47,940 --> 00:00:50,580
pasta /common/interceptors.

12
00:00:50,580 --> 00:00:55,690
Vamos abrir este TimeoutInterceptor recém-gerado,
e adicione alguma lógica lá.

13
00:00:55,690 --> 00:01:00,400
Em nosso exemplo, queremos encerrar um
pedido após um determinado período de tempo.

14
00:01:00,400 --> 00:01:07,090
Então vamos usar o operador timeout()
importado de "rxjs/operators" para conseguir isso.

15
00:01:07,090 --> 00:01:12,310
Para demonstrar isso facilmente, vamos definir um
`timeout` muito rápido de 3000 milissegundos.

16
00:01:12,310 --> 00:01:16,930
Isso significa que, quando uma solicitação é feita,
após 3 segundos, o processamento do pedido será

17
00:01:16,930 --> 00:01:19,690
cancelado automaticamente para nós.

18
00:01:19,690 --> 00:01:25,420
Para testá-lo. Vamos vincular este segundo interceptor
ao nosso aplicativo globalmente, e como não tem

19
00:01:25,420 --> 00:01:30,040
dependências, podemos adicionar isso em nosso arquivo main.ts.

20
00:01:30,040 --> 00:01:36,270
Então vamos adicionar nosso novo TimeoutInterceptor
aqui em nosso método useGlobalInterceptors().

21
00:01:36,270 --> 00:01:42,880
Observe que podemos vincular vários Interceptores
aqui simplesmente separando-os com vírgulas.

22
00:01:42,880 --> 00:01:46,090
Agora para ter certeza de que
nosso interceptor funciona corretamente.

23
00:01:46,090 --> 00:01:52,210
Vamos abrir o arquivo CoffeesController e
adicionar temporariamente uma função `setTimeout()` em nosso

24
00:01:52,210 --> 00:01:59,320
findAll() para simular um atraso muito longo.

25
00:01:59,320 --> 00:02:05,470
Vamos definir um tempo limite de 5 segundos, maior que o
3 segundos que colocamos em nosso interceptor para propositalmente

26
00:02:05,470 --> 00:02:08,650
acionar nosso TimeoutInterceptor.

27
00:02:08,650 --> 00:02:16,730
Perfeito. Agora vamos abrir a insônia e executar isso
endpoint fazendo uma solicitação para GET /coffees

28
00:02:21,080 --> 00:02:23,180
. Como podemos ver, após 3 segundos.

29
00:02:23,630 --> 00:02:28,850
Recebemos um erro 500
o que significa que nosso TimeoutInterceptor funcionou!

30
00:02:28,850 --> 00:02:32,180
No entanto, a mensagem de erro que recebemos
volta não é realmente descritivo.

31
00:02:32,180 --> 00:02:33,790
Diz "Erro interno do servidor".

32
00:02:34,130 --> 00:02:37,920
Mas como poderíamos fazer
esta mensagem mais amigável?

33
00:02:37,920 --> 00:02:39,830
Voltando ao nosso TimeoutInterceptor novamente.

34
00:02:40,250 --> 00:02:45,200
Vamos encadear outro operador chamado `catchError()`
dentro do nosso método pipe()

35
00:02:50,230 --> 00:02:57,740
. O operador RxJS catchError() nos permite
capturar todas as exceções que ocorreram dentro do fluxo.

36
00:02:57,740 --> 00:03:03,370
Na função de retorno de chamada que fornecemos aqui, podemos
verifique se o trono do erro é uma *instância* de

37
00:03:03,400 --> 00:03:04,880
`TimeoutError`.

38
00:03:04,880 --> 00:03:06,560
Que também é importado de 'rxjs'.

39
00:03:07,040 --> 00:03:14,300
Nesse caso, usamos uma função utilitária `throwError()`
de 'rxjs' para criar um fluxo que imediatamente

40
00:03:14,300 --> 00:03:17,030
emite um Error para o que for passado para ele.

41
00:03:17,570 --> 00:03:23,000
Como queremos que nossa mensagem de erro seja mais
específico para este cenário, vamos usar uma classe NestJS

42
00:03:23.000 --> 00:03:28.700
chamado RequestTimeoutException importado de @nestjs/common, então
podemos lançar o erro correto

43
00:03:28,700 --> 00:03:34,260
mensagem de volta para nossos usuários, informando-os
que a solicitação realmente expirou.

44
00:03:34,260 --> 00:03:41,100
Excelente. Então, vamos salvar nossas alterações e navegar de volta
à insônia e testar o ponto final mais uma vez.

45
00:03:41,100 --> 00:03:46,940
Como podemos ver. Desta vez recebemos o
408 com a mensagem descritiva "Request Timeout"

46
00:03:48,060 --> 00:03:52,960
. Então, nesta lição, aprendemos como
adicionar superpoderes adicionais aos nossos interceptores junto com alguns

47
00:03:52,960 --> 00:03:55,360
novos truques de RxJS.

48
00:03:55,360 --> 00:03:59,860
Todos os quais são cenários muito comuns e
útil na maioria de nossos aplicativos NestJS.

