1
00:00:00,920 --> 00:00:07,730
Interceptores, têm muitos recursos úteis inspirados
pela técnica de programação orientada a aspectos.

2
00:00:07,730 --> 00:00:15,330
Esta técnica visa aumentar a modularidade
permitindo a separação de transversais e preocupações.

3
00:00:15,330 --> 00:00:20,490
Os interceptadores conseguem isso adicionando comportamento adicional
ao código existente, sem modificar o código

4
00:00:20,490 --> 00:00:23,730
em si! Os interceptores tornam possível para nós:.

5
00:00:24,420 --> 00:00:27,990
1) Ligue lógica extra antes
ou após a execução do método.

6
00:00:28,950 --> 00:00:32,830
2) Transforme o "Resultado" retornado de um método.

7
00:00:32,830 --> 00:00:34,790
3) Transforme a "Exception" lançada de um método.

8
00:00:35,760 --> 00:00:38,190
4) Estenda o comportamento básico do método.

9
00:00:39,060 --> 00:00:43,830
5) Ou até mesmo substituindo completamente um método
- dependendo de uma condição específica.

10
00:00:44,250 --> 00:00:48,980
Por exemplo fazendo algo
como armazenar em cache várias respostas.

11
00:00:48,980 --> 00:00:52,440
Tudo bem. Então para aprender
como os interceptores funcionam conceitualmente.

12
00:00:52,440 --> 00:00:57,570
Vamos analisar um exemplo de caso de uso em que *sempre*
queremos que nossas respostas sejam localizadas dentro de um

13
00:00:57,570 --> 00:00:59,190
propriedade `data` (dados: resposta_aqui).

14
00:00:59,190 --> 00:01:02,670
E crie um novo interceptor
para lidar com isso para nós.

15
00:01:02,670 --> 00:01:07,290
Vamos chamar isso
novo interceptor WrapResponseInterceptor.

16
00:01:07,290 --> 00:01:13,980
Este novo interceptor lidará com *todas* as solicitações recebidas,
e "empacotar" nossos dados para nós automaticamente.

17
00:01:13,980 --> 00:01:18,120
Para começar. Vamos gerar um interceptor
class usando a Nest CLI digitando:.

18
00:01:18,180 --> 00:01:23,400
`ninho g
interceptor comum/interceptor/wrap-resposta

19
00:01:23,400 --> 00:01:27,160
Observe que geramos esse interceptor no
diretório /common/ como fizemos muitas vezes antes,

20
00:01:27,160 --> 00:01:31,340
já que este interceptor não está empatado
para qualquer domínio específico.

21
00:01:31,350 --> 00:01:37,310
Vamos abrir este WrapResponseInterceptor recém-gerado
arquivo e veja o que temos dentro.

22
00:01:37,310 --> 00:01:42,950
A Nest CLI gerou um interceptor de exemplo
para nós sem qualquer lógica de negócios.

23
00:01:42,950 --> 00:01:48,930
Semelhante aos Provedores, um Interceptor é
uma classe com o decorador @Injectable.

24
00:01:48,930 --> 00:01:56,010
Todos os interceptores devem implementar o
Interface `NestInterceptor` exportada de @nestjs/common.

25
00:01:56,010 --> 00:02:00,870
Esta interface requer que forneçamos
o método `intercept()` dentro de nossa classe.

26
00:02:00,870 --> 00:02:06,420
O método intercept() deve retornar um
Observável da biblioteca RxJS.

27
00:02:06,420 --> 00:02:08,040
Se você não estiver familiarizado com RxJS.

28
00:02:08,430 --> 00:02:11,850
É uma biblioteca para
Programação reativa usando observáveis.

29
00:02:11,850 --> 00:02:16,110
Facilitando a composição
código base assíncrono ou de retorno de chamada.

30
00:02:17,020 --> 00:02:21,010
O próprio RxJS está fora do escopo
do que podemos mergulhar aqui.

31
00:02:21,280 --> 00:02:26,380
Só sei que é um poderoso
alternativa para promessas ou retornos de chamada.

32
00:02:26,380 --> 00:02:31,090
De volta ao nosso código. A interface `CallHandler`
aqui implementa o método `handle()` (next.handle()),

33
00:02:31,480 --> 00:02:36,440
que você pode usar para invocar o
método manipulador de rota dentro do seu interceptor.

34
00:02:36,440 --> 00:02:40,110
Se você não chamar o método handle()
em sua implementação do método de interceptação.

35
00:02:40,580 --> 00:02:45,010
O método do manipulador de rotas *WON'T
ser executado em tudo*.

36
00:02:45,010 --> 00:02:50,530
Essa abordagem significa que o método intercept()
efetivamente "empacota" o fluxo de solicitação/resposta -

37
00:02:51,070 --> 00:02:57,670
permitindo-nos implementar a lógica personalizada tanto *antes*
e *após* a execução da rota final

38
00:02:57,760 --> 00:03:03,490
manipulador. Tudo bem, então nós cobrimos
muita teoria até agora.

39
00:03:03,490 --> 00:03:12,760
Vamos adicionar alguns console.log()'s, para ver onde
interceptadores se encaixam no ciclo de vida de solicitação/resposta.

40
00:03:12,760 --> 00:03:16,870
Como chamamos o console.log()
*antes* de chamar o método next.handle().

41
00:03:17,740 --> 00:03:23,590
Nossa mensagem "Antes..." deve aparecer no console
ANTES do manipulador de rota real ser executado por

42
00:03:23,590 --> 00:03:25,840
o quadro.

43
00:03:25,840 --> 00:03:28,840
Desde handle retorna um RxJS Observable.

44
00:03:29,260 --> 00:03:34,680
Temos uma vasta escolha de operadores que
pode usar para manipular o "stream" aqui.

45
00:03:34,680 --> 00:03:41,430
Neste exemplo. Estamos usando o operador tap()
que invoca uma função de registro anônimo sobre

46
00:03:41,430 --> 00:03:44,880
finalização graciosa do fluxo observável.

47
00:03:44,880 --> 00:03:49,920
Mas (o operador tap()) não interfere de outra forma
com o ciclo de resposta em tudo.

48
00:03:49,920 --> 00:03:55,080
O argumento `data` da função de seta e passamos
no operador tap aqui, é de fato **o

49
00:03:55,080 --> 00:03:58,290
resposta** enviada de volta do manipulador de rotas!

50
00:03:58,290 --> 00:04:02,060
Basicamente pense nisso como qualquer coisa
volta do nosso endpoint!

51
00:04:02,060 --> 00:04:05,520
Aqui. Estamos apenas fazendo um
console.log() para dizer "Depois..."

52
00:04:05,520 --> 00:04:08,880
E registrando esses `dados` de volta também.

53
00:04:08,880 --> 00:04:10,590
Para testar tudo.

54
00:04:10,590 --> 00:04:14,470
Vamos vincular este interceptor
para nossa aplicação globalmente.

55
00:04:14,470 --> 00:04:17,230
Vamos abrir nosso arquivo main.ts e adicionar:

56
00:04:17,630 --> 00:04:25,650
`app.UseGlobalInterceptors()`, passando
`novo WrapResponseInterceptor`.

57
00:04:25,650 --> 00:04:26,580
Ótimo agora.

58
00:04:26,910 --> 00:04:31,650
Vamos garantir que nosso aplicativo esteja sendo executado em
o pano de fundo e vamos navegar para insônia e

59
00:04:31,650 --> 00:04:36,010
testar qualquer endpoint em nosso aplicativo.

60
00:04:36,010 --> 00:04:40,330
Primeiro vamos ter certeza de que temos
alguns Cafés armazenados em nosso banco de dados.

61
00:04:40,330 --> 00:04:47,500
Para fazê-lo. Vamos acertar o POST
/coffees e adicione um Coffee aleatório.

62
00:04:47,500 --> 00:04:52,330
Perfeito. Agora vamos atingir o ponto final GET /coffees
e volte para o VSCode para ver aqueles

63
00:04:52,330 --> 00:04:57,500
console.log()'s no terminal.

64
00:04:57,500 --> 00:05:00,230
Como podemos ver "Antes..." foi registrado.

65
00:05:00,230 --> 00:05:05,660
E *depois* "Depois...", seguido pelo real
`value` do nosso método findAll(), que representa

66
00:05:05,660 --> 00:05:07,580
o ponto de extremidade /coffees.

67
00:05:07,580 --> 00:05:10,490
Parece que nosso interceptor funcionou!

68
00:05:10,490 --> 00:05:15,790
Vamos abrir a insônia novamente,
e teste outro endpoint.

69
00:05:15,790 --> 00:05:21,940
Vamos testar (GET) /coffees/1 desta vez.

70
00:05:21,940 --> 00:05:26,140
Desta vez, devemos ver um único objeto
seguindo o log "Depois..." em nosso terminal.

71
00:05:26,590 --> 00:05:27,940
Ótimo até agora tudo bem.

72
00:05:28,930 --> 00:05:35,110
Agora que pudemos ver como os interceptores
trabalho e sua parte no ciclo de vida de solicitação/resposta.

73
00:05:35,110 --> 00:05:40,060
Vamos implementar nossa ideia de "data wrapper" sobre a qual falamos
no início desta lição e "enrole"

74
00:05:40,060 --> 00:05:43,650
nossa resposta está dentro de uma propriedade `data`.

75
00:05:43,650 --> 00:05:53,270
Para fazer isso vamos substituir o
função tap() com o operador map().

76
00:05:53,270 --> 00:05:59,300
O operador map() recebe um valor de
o fluxo e retorna um modificado.

77
00:05:59,300 --> 00:06:03,110
Como queríamos envolver tudo
respostas na propriedade `data`.

78
00:06:03,110 --> 00:06:07,730
Vamos retornar um objeto com uma chave/valor de dados.

79
00:06:07,730 --> 00:06:13,820
Toda vez que esta função map() é chamada, ela retorna
um novo objeto com uma propriedade `data` preenchida com

80
00:06:13,820 --> 00:06:16,810
nossa *resposta original*.

81
00:06:16,810 --> 00:06:21,130
Lembre-se de tudo o que fizemos aqui é principalmente para
fins de demonstração, mas espero que agora você possa

82
00:06:21,130 --> 00:06:26,440
ver o poder dos interceptores, e como há um
potencial para fazer tantas outras coisas aqui:.

83
00:06:26,590 --> 00:06:31,300
Como passar números de versão,
rastreamento de análise, etc etc.

84
00:06:31,300 --> 00:06:36,540
Tudo bem, então vamos salvar todas as nossas alterações
abra a insônia e teste este interceptor.

85
00:06:36,540 --> 00:06:42,070
Vamos executar qualquer solicitação HTTP e ver
o que o aplicativo envia de volta para nós.

86
00:06:42,070 --> 00:06:47,230
Perfeito como podemos ver, a resposta foi
automaticamente envolvido em um objeto dentro do `data`

87
00:06:47,230 --> 00:06:54,280
propriedade. Então, encerrando - neste vídeo nós
mostrado como os interceptores nos dão um poder incrível

88
00:06:54,280 --> 00:06:59,940
para manipular solicitações OU respostas,
sem alterar *qualquer* código subjacente.

